#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <cstdlib>

#include <sylvan.h>
#include <sylvan_obj.hpp>

using namespace sylvan;

int solve() {
    LACE_ME;
<% n = 0 -%>
<% self.board.each_with_index do |row, j|
  row.each_with_index do |field, i| -%>
    <% next if field == Field::WALL %>
    Bdd man_<%= "#{i}_#{j}" %> = Bdd::bddVar(<%= n += 1 %>);
    Bdd man_<%= "#{i}_#{j}" %>_next = Bdd::bddVar(<%= n += 1 %>);
    Bdd block_<%= "#{i}_#{j}" %> = Bdd::bddVar(<%= n += 1 %>);
    Bdd block_<%= "#{i}_#{j}" %>_next = Bdd::bddVar(<%= n += 1 %>);
  <% end -%>
<% end -%>

<%
initial_state = self.board.each_with_index.map do |row, j|
  row.each_with_index.map do |field, i|
    next if field == Field::WALL
    ["#{field == Field::MAN ? '' : '!'}man_#{i}_#{j}",
     "#{field == Field::BLOCK ? '' : '!'}block_#{i}_#{j}"]
  end
end
-%>
    Bdd initial_state = <%= initial_state.join(' * ') %>;
    Bdd goal_state = <%= goals.map{|b| "block_#{b.x}_#{b.y}"}.join(' * ') -%>;

<% self.fields.each do |field| -%>
  <% position = "#{field.x}_#{field.y}" %>
    Bdd freeze_man_<%= position %> = (man_<%= position %> * man_<%= position %>_next) + (!man_<%= position %> * !man_<%= position %>_next);
    Bdd freeze_block_<%= position %> = (block_<%= position %> * block_<%= position %>_next) + (!block_<%= position %> * !block_<%= position %>_next);
    Bdd move_man_<%= position %> = !freeze_man_<%= position %>;
    Bdd move_block_<%= position %> = !freeze_block_<%= position %>;
<% end -%>

<%
def find_transitions_man(delta_x, delta_y)
  self.transitionable_fields(1, delta_x, delta_y).map do |field|
    frozen_locations = self.fields.reject { |f| (0..1).any? { |i| f.x == field.x + i * delta_x && f.y == field.y + i * delta_y } }
    ["man_#{field.x}_#{field.y}", "!man_#{field.x}_#{field.y}_next", "!man_#{field.x + delta_x}_#{field.y + delta_y}", "man_#{field.x + delta_x}_#{field.y + delta_y}_next"] +
      frozen_locations.flat_map { |f| ["freeze_man_#{f.x}_#{f.y}", "freeze_block_#{f.x}_#{f.y}"] }
  end
end

def find_transitions_block(delta_x, delta_y)
  self.transitionable_fields(2, delta_x, delta_y).map do |field|
    frozen_locations = self.fields.reject { |f| (0..2).any? { |i| f.x == field.x + i * delta_x && f.y == field.y + i * delta_y } }
    ["man_#{field.x}_#{field.y}", "!man_#{field.x}_#{field.y}_next", "!man_#{field.x}_#{field.y + delta_y}", "man_#{field.x}_#{field.y + delta_y}_next"] +
      ["block_#{field.x}_#{field.y + delta_y}", "!block_#{field.x}_#{field.y + delta_y}_next", "!block_#{field.x + 2 * delta_x}_#{field.y + 2 * delta_y}", "block_#{field.x + 2 * delta_x}_#{field.y + 2 * delta_y}_next"] +
      frozen_locations.flat_map { |f| ["freeze_man_#{f.x}_#{f.y}", "freeze_block_#{f.x}_#{f.y}"] }
  end
end
-%>

Bdd north_transitions = <%= (find_transitions_man(-1, 0) + find_transitions_block(-1, 0)).map {|transition| "(#{transition.join(' * ')})"} .join(' + ') %>;
Bdd south_transitions = <%= (find_transitions_man(1, 0) + find_transitions_block(1, 0)).map {|transition| "(#{transition.join(' * ')})"} .join(' + ') %>;
Bdd east_transitions = <%= (find_transitions_man(0, 1) + find_transitions_block(0, 1)).map {|transition| "(#{transition.join(' * ')})"} .join(' + ') %>;
Bdd west_transitions = <%= (find_transitions_man(0, -1) + find_transitions_block(0, -1)).map {|transition| "(#{transition.join(' * ')})"} .join(' + ') %>;

    return 0;
}

int main() {
    lace_init(0, 0);
    lace_startup(0, NULL, NULL);

    sylvan_init_package(1LL<<21, 1LL<<25, 1LL<<20, 1LL<<24);
    sylvan_init_bdd(6);

    solve();
    return 0;
}
